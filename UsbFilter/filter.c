#include <WDM.H>
#include <usbiodef.h>
#include <usbdi.h>
#include <usb100.h>
#include <usbdlib.h>

#include "filter.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(INIT, DriverEntry)
        #pragma alloc_text(PAGE, USB_AddDevice)
        #pragma alloc_text(PAGE, USB_DriverUnload)
#endif

static char* irpname[] = {
		"IRP_MJ_CREATE",
		"IRP_MJ_CREATE_NAMED_PIPE",
		"IRP_MJ_CLOSE",
		"IRP_MJ_READ",
		"IRP_MJ_WRITE",
		"IRP_MJ_QUERY_INFORMATION",
		"IRP_MJ_SET_INFORMATION",
		"IRP_MJ_QUERY_EA",
		"IRP_MJ_SET_EA",
		"IRP_MJ_FLUSH_BUFFERS",
		"IRP_MJ_QUERY_VOLUME_INFORMATION",
		"IRP_MJ_SET_VOLUME_INFORMATION",
		"IRP_MJ_DIRECTORY_CONTROL",
		"IRP_MJ_FILE_SYSTEM_CONTROL",
		"IRP_MJ_DEVICE_CONTROL",
		"IRP_MJ_INTERNAL_DEVICE_CONTROL",
		"IRP_MJ_SHUTDOWN",
		"IRP_MJ_LOCK_CONTROL",
		"IRP_MJ_CLEANUP",
		"IRP_MJ_CREATE_MAILSLOT",
		"IRP_MJ_QUERY_SECURITY",
		"IRP_MJ_SET_SECURITY",
		"IRP_MJ_POWER",
		"IRP_MJ_SYSTEM_CONTROL",
		"IRP_MJ_DEVICE_CHANGE",
		"IRP_MJ_QUERY_QUOTA",
		"IRP_MJ_SET_QUOTA",
		"IRP_MJ_PNP",
		};

static char* urb_name[] = {
		"URB_FUNCTION_SELECT_CONFIGURATION",
		"URB_FUNCTION_SELECT_INTERFACE",
		"URB_FUNCTION_ABORT_PIPE",
		"URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL",
		"URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL",
		"URB_FUNCTION_GET_FRAME_LENGTH",
		"URB_FUNCTION_SET_FRAME_LENGTH",
		"URB_FUNCTION_GET_CURRENT_FRAME_NUMBER",
		"URB_FUNCTION_CONTROL_TRANSFER",
		"URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER",
		"URB_FUNCTION_ISOCH_TRANSFER",
		"URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE",
		"URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE",
		"URB_FUNCTION_SET_FEATURE_TO_DEVICE",
		"URB_FUNCTION_SET_FEATURE_TO_INTERFACE",
		"URB_FUNCTION_SET_FEATURE_TO_ENDPOINT",
		"URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE",
		"URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE",
		"URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT",
		"URB_FUNCTION_GET_STATUS_FROM_DEVICE",
		"URB_FUNCTION_GET_STATUS_FROM_INTERFACE",
		"URB_FUNCTION_GET_STATUS_FROM_ENDPOINT",
		"URB_FUNCTION_RESERVED0",
		"URB_FUNCTION_VENDOR_DEVICE",
		"URB_FUNCTION_VENDOR_INTERFACE",
		"URB_FUNCTION_VENDOR_ENDPOINT",
		"URB_FUNCTION_CLASS_DEVICE",
		"URB_FUNCTION_CLASS_INTERFACE",
		"URB_FUNCTION_CLASS_ENDPOINT",
		"URB_FUNCTION_RESERVED",
		"URB_FUNCTION_RESET_PIPE",
		"URB_FUNCTION_CLASS_OTHER",
		"URB_FUNCTION_VENDOR_OTHER",
		"URB_FUNCTION_GET_STATUS_FROM_OTHER",
		"URB_FUNCTION_CLEAR_FEATURE_TO_OTHER",
		"URB_FUNCTION_SET_FEATURE_TO_OTHER",
		"URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT",
		"URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT",
		"URB_FUNCTION_GET_CONFIGURATION",
		"URB_FUNCTION_GET_INTERFACE",
		"URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE",
		"URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE",
	};

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
	{
	int i;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(RegistryPath);

    DBGOUT(("DriverEntry")); 

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
		{
        DriverObject->MajorFunction[i] = USB_Dispatch; 
		}

    DriverObject->DriverExtension->AddDevice = USB_AddDevice;
    DriverObject->DriverUnload = USB_DriverUnload;

    return STATUS_SUCCESS;
	}

NTSTATUS USB_AddDevice(IN PDRIVER_OBJECT driverObj, IN PDEVICE_OBJECT physicalDevObj)
	{
    NTSTATUS status;
    PDEVICE_OBJECT filterDevObj = NULL;
	PDEVICE_OBJECT controlDevObj = NULL;
    
    PAGED_CODE();

    DBGOUT(("USB_AddDevice: drvObj=%ph, pdo=%ph", driverObj, physicalDevObj)); 

	/// for filter device...
    status = IoCreateDevice(driverObj, sizeof(struct DEVICE_EXTENSION), NULL, FILE_DEVICE_UNKNOWN, 
                                FILE_AUTOGENERATED_DEVICE_NAME, FALSE, &filterDevObj);
    
    if (NT_SUCCESS(status))
		{
        struct DEVICE_EXTENSION *devExt;	/// for filter
		struct DEVICE_EXTENSION *devExt2;	/// for control
		UNICODE_STRING DevName;

		RtlInitUnicodeString(&DevName, L"\\Device\\USBfilterDrv");
		RtlInitUnicodeString(&DevlinkName, BEACON_USB_FILTER);

		/// for control device...
		status = IoCreateDevice(driverObj, sizeof(struct DEVICE_EXTENSION), &DevName, FILE_DEVICE_UNKNOWN,
									0, FALSE, &controlDevObj);

		if (NT_SUCCESS(status))
			{
			controlDevObj->Flags |= DO_DEVICE_INITIALIZING;
			devExt2 = (struct DEVICE_EXTENSION *)controlDevObj->DeviceExtension;
			RtlZeroMemory(devExt2, sizeof(struct DEVICE_EXTENSION));
			devExt2->signature = DEVICE_EXTENSION_SIGNATURE;
			devExt2->state = STATE_INITIALIZED;
			devExt2->filterDevObj = filterDevObj;
			devExt2->physicalDevObj = physicalDevObj;
			devExt2->controlDevObj = controlDevObj;
			devExt2->WhichObj = CONTROL_DEVICE_OBJ;
			
			devExt2->pendingActionCount = 0;

			controlDevObj->Flags |= DO_BUFFERED_IO | DO_DIRECT_IO;
			controlDevObj->Flags &= ~DO_DEVICE_INITIALIZING;

			DBGOUT(("Created controlDevObj : %ph", controlDevObj));
			
			status = IoCreateSymbolicLink(&DevlinkName, &DevName);
			if (NT_SUCCESS(status))
				{
				DBGOUT(("Created SymbolicLink"));
				}
			else
				{
				DBGOUT(("CreateSymbolicLink failed!!! : %04x", status));
				IoDeleteDevice(filterDevObj);
				IoDeleteDevice(controlDevObj);

				return status;
				}
			}
		else
			{
			DBGOUT(("Control Device Object Creation failed!!! : %04x", status));
			IoDeleteDevice(filterDevObj);

			return status;
			}

        ASSERT(filterDevObj);

		devExt = (struct DEVICE_EXTENSION *)filterDevObj->DeviceExtension;
		RtlZeroMemory(devExt, sizeof(struct DEVICE_EXTENSION));
        devExt->signature = DEVICE_EXTENSION_SIGNATURE;
        devExt->state = STATE_INITIALIZED;
        devExt->filterDevObj = filterDevObj;
        devExt->physicalDevObj = physicalDevObj;
		devExt->controlDevObj = controlDevObj;
		devExt->WhichObj = FILTER_DEVICE_OBJ;
		devExt->readflag = CAPTURE_STOP;
		devExt->writeflag = CAPTURE_STOP;
		devExt->bThreadStop = true;
		devExt->bInit = false;
		devExt->packet_Event = devExt->removeEvent_app = NULL;

		/// for Data capture...
		KeInitializeSemaphore(&devExt->pSemaphore, 0, MAX_PACKET);
		ExInitializeFastMutex(&devExt->FMutex);
		/// create thread...
	/*	status = PsCreateSystemThread(&hThread, 0, NULL, NULL, NULL, (PKSTART_ROUTINE)CaptureThread, devExt);
		if (NT_SUCCESS(status))
			{
			ObReferenceObjectByHandle(hThread, THREAD_ALL_ACCESS, NULL, KernelMode, (PVOID *)&devExt->pThread, NULL);
			ZwClose(hThread);
			}
		else
			{
			DBGOUT(("CreateThread failed!!!"));
			IoDeleteSymbolicLink(&DevlinkName);
			IoDeleteDevice(filterDevObj);
			IoDeleteDevice(controlDevObj);

			return status;
			}
		//*/
        
        devExt->pendingActionCount = 0;
        KeInitializeEvent(&devExt->removeEvent, NotificationEvent, FALSE);

		/// for packet delay
		KeInitializeEvent(&devExt->kTimerEvent, SynchronizationEvent, FALSE);
		KeInitializeTimer(&devExt->kTimer);
		KeInitializeDpc(&devExt->kTimerDpc, TimerDpc, devExt);
		devExt->lnTimer = RtlConvertLongToLargeInteger(-1*10000000);

        devExt->topDevObj = IoAttachDeviceToDeviceStack(filterDevObj, physicalDevObj);

        ASSERT(devExt->topDevObj);
		
		devExt2->topDevObj = devExt->topDevObj;
        DBGOUT(("Created filterDevObj %ph attached to %ph", filterDevObj, devExt->topDevObj));

		TIME_SYNCHRONIZE(&devExt->start_time);

        filterDevObj->Flags |= (devExt->topDevObj->Flags & (DO_BUFFERED_IO | DO_DIRECT_IO));
        filterDevObj->Flags |= (devExt->topDevObj->Flags & (DO_POWER_INRUSH | DO_POWER_PAGABLE /*| DO_POWER_NOOP*/)); 
        filterDevObj->Flags &= ~DO_DEVICE_INITIALIZING;
	
        RegistryAccessSample(devExt, devExt->physicalDevObj);
		}
		
    ASSERT(NT_SUCCESS(status));
    return status;
	}

VOID USB_DriverUnload(IN PDRIVER_OBJECT DriverObject)
	{
	PAGED_CODE();

	DBGOUT(("USB_DriverUnload"));
	}

NTSTATUS USB_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
	{
    struct DEVICE_EXTENSION *devExt;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN passIrpDown = TRUE;
    UCHAR majorFunc, minorFunc;
    NTSTATUS status = STATUS_SUCCESS;

    devExt = DeviceObject->DeviceExtension;
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    majorFunc = irpSp->MajorFunction;
    minorFunc = irpSp->MinorFunction;

	if (devExt->WhichObj == FILTER_DEVICE_OBJ)
		{
		/*
		 *  For all IRPs except REMOVE, we increment the PendingActionCount
		 *  across the dispatch routine in order to prevent a race condition with
		 *  the REMOVE_DEVICE IRP (without this increment, if REMOVE_DEVICE
		 *  preempted another IRP, device object and extension might get
		 *  freed while the second thread was still using it).
		 */
		if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE)))
			{
			IncrementPendingActionCount(devExt);
			}

		if ((majorFunc != IRP_MJ_PNP) && (majorFunc != IRP_MJ_CLOSE) && 
			((devExt->state == STATE_REMOVING) || (devExt->state == STATE_REMOVED)))
			{
			/*
			 *  While the device is being removed, 
			 *  we only pass down the PNP and CLOSE IRPs.
			 *  We fail all other IRPs.
			 */
			status = Irp->IoStatus.Status = STATUS_DELETE_PENDING;
			IoCompleteRequest(Irp, IO_NO_INCREMENT);
			passIrpDown = FALSE;
			}
		else 
			{
			switch (majorFunc)
				{
				case IRP_MJ_PNP:
					status = USB_PnP(devExt, Irp);
					passIrpDown = FALSE;
					break;

				case IRP_MJ_POWER:
					status = USB_Power(devExt, Irp);
					passIrpDown = FALSE;
					break;

				case IRP_MJ_INTERNAL_DEVICE_CONTROL:
				//	status = USB_IoInternal(devExt, Irp);
				//	passIrpDown = FALSE;
					break;

				case IRP_MJ_READ:
				case IRP_MJ_WRITE:
					status = USB_Read_Write(devExt, Irp);
					passIrpDown = FALSE;
					break;

				case IRP_MJ_DEVICE_CONTROL:
				case IRP_MJ_CREATE:
				case IRP_MJ_CLOSE:
				case IRP_MJ_SYSTEM_CONTROL:
				default:
					break;
				}
			}

		if (passIrpDown)
			{
			IoCopyCurrentIrpStackLocationToNext(Irp);
			status = IoCallDriver(devExt->topDevObj, Irp);
			}

		if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE)))
			{
			DecrementPendingActionCount(devExt);
			}

		}
	else	// Control Device Object...
		{
		Irp->IoStatus.Status = STATUS_SUCCESS;
		Irp->IoStatus.Information = 0;
		switch(majorFunc)
			{
			case IRP_MJ_CREATE:
			case IRP_MJ_CLOSE:
				break;

			case IRP_MJ_DEVICE_CONTROL:
				status = USB_IoCtrl(devExt, Irp);
				break;

			default:
				break;
			}
		
		IoCompleteRequest(Irp, IO_NO_INCREMENT);
		}
	
    return status;
	}

NTSTATUS USB_Read_Write(struct DEVICE_EXTENSION *devExt, PIRP irp)
	{
	NTSTATUS status = STATUS_SUCCESS;
	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
	DWORD wLen;
	bool bWhich = devExt->bWhichBuffer_write;
	KIRQL oldIrql;

	if (IRP_MJ_READ == irpSp->MajorFunction)
		{
		IoCopyCurrentIrpStackLocationToNext(irp);
		IoSetCompletionRoutine(irp, USB_IoReadCompletion, devExt, TRUE, TRUE, TRUE);
		status = IoCallDriver(devExt->topDevObj, irp);
		}
	else
		{
		/// for packet delay
	//	KeSetTimer(&devExt->kTimer, devExt->lnTimer, &devExt->kTimerDpc);
	//	KeWaitForSingleObject(&devExt->kTimerEvent, Executive, KernelMode, FALSE, &devExt->lnTimer);

		wLen = irpSp->Parameters.Write.Length;
		if (wLen > 0 && devExt->writeflag == CAPTURE_START)
			{
			/// write capture
		//	KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
			oldIrql = KeGetCurrentIrql();
			if (oldIrql < DISPATCH_LEVEL)
				{
				ExAcquireFastMutex(&devExt->FMutex);
			//	KeWaitForSingleObject(&devExt->kTimerEvent, Executive, KernelMode, FALSE, &devExt->lnTimer);
				}

			if (wLen + devExt->wWriteOffset[bWhich] > MAX_BUFFER)
				{
				bWhich = bWhich ^ 0x01;
				devExt->wWriteOffset[bWhich] = 0;
				devExt->bWhichBuffer_write = bWhich;
				}

		//	DBGOUT(("write len : %u(%u)", wLen, bWhich));
			devExt->PkHdr[devExt->nCount].code = wWriteFlag;
			devExt->PkHdr[devExt->nCount].length = (WORD)wLen;
			devExt->PkHdr[devExt->nCount].offset = (WORD)devExt->wWriteOffset[bWhich];
			devExt->PkHdr[devExt->nCount].bFlag = bWhich;
			GET_TIME(&devExt->PkHdr[devExt->nCount].tv, &devExt->start_time);
			if (devExt->nCount >= MAX_PACKET-1)
				devExt->nCount = 0;
			else
				devExt->nCount++;

			RtlCopyMemory(devExt->pWriteBuffer[bWhich] + devExt->wWriteOffset[bWhich], irp->AssociatedIrp.SystemBuffer, wLen);
			InterlockedExchangeAdd((PLONG)&devExt->wWriteOffset[bWhich], wLen);
		//	devExt->wWriteOffset[bWhich] += wLen;
			if (oldIrql < DISPATCH_LEVEL)
				ExReleaseFastMutex(&devExt->FMutex);

		//	KeLowerIrql(oldIrql);
			KeReleaseSemaphore(&devExt->pSemaphore, 0, 1, FALSE);
			}
		IoCopyCurrentIrpStackLocationToNext(irp);
        status = IoCallDriver(devExt->topDevObj, irp);
		}

	return status;
	}

NTSTATUS USB_IoReadCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP irp, IN PVOID Context)
	{
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(irp);
	struct DEVICE_EXTENSION *devExt = (struct DEVICE_EXTENSION *)Context;
	DWORD wLen;
	bool bWhich = devExt->bWhichBuffer_read;
	KIRQL oldIrql;
	
	wLen = irp->IoStatus.Information;
	if (wLen > 0 && devExt->readflag == CAPTURE_START)
		{
		/// read capture
	//	KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
		oldIrql = KeGetCurrentIrql();
		if (oldIrql < DISPATCH_LEVEL)
			{
			ExAcquireFastMutex(&devExt->FMutex);
		//	KeWaitForSingleObject(&devExt->kTimerEvent, Executive, KernelMode, FALSE, &devExt->lnTimer);
			DBGOUT(("Read delay..."));
			}
		else
			{
			DBGOUT(("Irql == DISPATCH_LEVEL"));
			}

		if (wLen + devExt->wReadOffset[bWhich] > MAX_BUFFER)
			{
			bWhich = bWhich ^ 0x01;
			devExt->wReadOffset[bWhich] = 0;
			devExt->bWhichBuffer_read = bWhich;
			}

	//	DBGOUT(("read len : %u(%u)", wLen, bWhich));
		devExt->PkHdr[devExt->nCount].code = wReadFlag;
		devExt->PkHdr[devExt->nCount].length = (WORD)wLen;
		devExt->PkHdr[devExt->nCount].offset = (WORD)devExt->wReadOffset[bWhich];
		devExt->PkHdr[devExt->nCount].bFlag = bWhich;
		GET_TIME(&devExt->PkHdr[devExt->nCount].tv, &devExt->start_time);
		if (devExt->nCount >= MAX_PACKET-1)
			devExt->nCount = 0;
		else
			devExt->nCount++;
		
		RtlCopyMemory(devExt->pReadBuffer[bWhich] + devExt->wReadOffset[bWhich], irp->AssociatedIrp.SystemBuffer, wLen);
		InterlockedExchangeAdd((PLONG)&devExt->wReadOffset[bWhich], wLen);
	//	devExt->wReadOffset[bWhich] += wLen;
		if (oldIrql < DISPATCH_LEVEL)
			ExReleaseFastMutex(&devExt->FMutex);

	//	KeLowerIrql(oldIrql);
		KeReleaseSemaphore(&devExt->pSemaphore, 0, 1, FALSE);
		}

	if (irp->PendingReturned)
		{
		IoMarkIrpPending(irp);
		}

	return irp->IoStatus.Status;
	}

NTSTATUS USB_IoCtrl(struct DEVICE_EXTENSION *devExt, PIRP irp)
	{
	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
	ULONG dwCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
	struct DEVICE_EXTENSION *filtExt = devExt->filterDevObj->DeviceExtension;
	ULONG dwReadBufferSize = 0, dwTemp = 0;
	EVENT_STRUCT* user_event;
	NTSTATUS status = STATUS_SUCCESS;
//	KIRQL oldIrql;
	UCHAR* pTemp;
	DWORD dwCount;

	switch (dwCode)
		{
		case IOCTL_TEST_BUFFERED:
			RtlCopyMemory(irp->AssociatedIrp.SystemBuffer, &DRIVER_VERSION, sizeof(ULONG));
			irp->IoStatus.Information = sizeof(ULONG);
			break;
			
		case IOCTL_CAPTURE_READ_DATA:	/// obsolete
			break;

		case IOCTL_CAPTURE_WRITE_DATA:	/// obsolete
			break;

		case IOCTL_CAPTURE_DATA:		/// both read and write data
		//	KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
			ExAcquireFastMutex(&filtExt->FMutex);
			/// copy data
			pTemp = (UCHAR *)MmGetSystemAddressForMdlSafe(irp->MdlAddress, NormalPagePriority);
			dwCount = filtExt->nMergeCount;
			RtlCopyMemory(pTemp, &dwCount, dwUlongSize);
			dwTemp = dwUlongSize;
			RtlCopyMemory(pTemp+dwTemp, filtExt->pCaptureHdr, nPKHDR_SIZE*dwCount);
			dwTemp += nPKHDR_SIZE*dwCount;
			RtlCopyMemory(pTemp+dwTemp, filtExt->pCaptureBuffer, filtExt->dwMergeOffset);
							//filtExt->pCaptureHdr[dwCount-1].offset + filtExt->pCaptureHdr[dwCount-1].length);

			irp->IoStatus.Information = filtExt->dwMergeOffset + dwTemp;
			filtExt->nMergeCount = 0;
			filtExt->dwMergeOffset = 0;
			ExReleaseFastMutex(&filtExt->FMutex);
		//	KeLowerIrql(oldIrql);
			break;

		case IOCTL_CAPTURE_STOP:
			DBGOUT(("Capture stop"));
			if (filtExt->bInit)
				CaptureInit(filtExt, false);

			break;

		case IOCTL_SET_EVENT:
			if (filtExt->bInit)
				CaptureInit(filtExt, false);
			
			user_event = (EVENT_STRUCT *)irp->AssociatedIrp.SystemBuffer;
			status = ObReferenceObjectByHandle(user_event->hPacket, SYNCHRONIZE, NULL, KernelMode, 
												(PVOID *)&filtExt->packet_Event, NULL);
			if (NT_SUCCESS(status))
				{
				status = ObReferenceObjectByHandle(user_event->hRemove, SYNCHRONIZE, NULL, KernelMode,
												(PVOID *)&filtExt->removeEvent_app, NULL);
				if (NT_SUCCESS(status))
					{
					DBGOUT(("Set Event"));
					}
				else
					{
					DBGOUT(("Set Event failed!!!"));
					ObDereferenceObject(filtExt->packet_Event);
					}
				}
			else
				{
				DBGOUT(("Set Event failed!!!"));
				}
			
			irp->IoStatus.Information = 0;
			break;

		case IOCTL_CAPTURE_START:
			status = CaptureInit(filtExt, true);
			break;
			
		default:
			break;
		}

	return status;//STATUS_SUCCESS;
	}

VOID CaptureThread(IN PVOID Context)
	{
	bool bAt = false, bPPP = false, bPacket = false;
	enum AT_RESPONSE eAtRes = STOP_LF;
	int nCurCount = 0, nCapCount = 0;
	bool bWhich = 0, bIndex = 0, bHdr = 0;
	DWORD dwOffset = 0, dwReadSize = 0;
	unsigned char *pTemp, *pReadTemp;
	struct DEVICE_EXTENSION *devExt;
	int i;
	//KIRQL irql;
	pTemp = ExAllocatePool(NonPagedPool, 4096);
	devExt = (struct DEVICE_EXTENSION *)Context;
	KeSetPriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

	DBGOUT(("CreateThread..."));
	while (1)
		{
		KeWaitForSingleObject(&devExt->pSemaphore, Executive, KernelMode, FALSE, NULL);
		if (devExt->bThreadStop)
			{
			ExFreePool(pTemp);
			PsTerminateSystemThread(STATUS_SUCCESS);
			}

		/// packet Ã³¸®...
		bPacket = false;
			
		bWhich = (bool)devExt->PkHdr[nCapCount].bFlag;
		if (devExt->PkHdr[nCapCount].code == wWriteFlag)
			{
			ExAcquireFastMutex(&devExt->FMutex);
			devExt->pCaptureHdr[devExt->nMergeCount].code = devExt->PkHdr[nCapCount].code;
			devExt->pCaptureHdr[devExt->nMergeCount].length = devExt->PkHdr[nCapCount].length;
			devExt->pCaptureHdr[devExt->nMergeCount].offset = devExt->dwTotalOffset;
			devExt->pCaptureHdr[devExt->nMergeCount].tv = devExt->PkHdr[nCapCount].tv;
			RtlCopyMemory(devExt->pCaptureBuffer + devExt->dwMergeOffset, 
						  devExt->pWriteBuffer[bWhich] + devExt->PkHdr[nCapCount].offset, 
						  devExt->PkHdr[nCapCount].length);

		//	InterlockedExchangeAdd(&devExt->dwTotalOffset, devExt->PkHdr[nCapCount].length);
		//	InterlockedExchangeAdd(&devExt->dwMergeOffset, devExt->PkHdr[nCapCount].length);
			devExt->dwTotalOffset += devExt->PkHdr[nCapCount].length;
			devExt->dwMergeOffset += devExt->PkHdr[nCapCount].length;
			if (devExt->nMergeCount >= MAX_PACKET-1)
				{
				devExt->nMergeCount = 0;
				devExt->dwMergeOffset = 0;
				}
			else
				devExt->nMergeCount++;

			ExReleaseFastMutex(&devExt->FMutex);
			KeSetEvent(devExt->packet_Event, 0, FALSE);
		//	DBGOUT(("write packet merge..."));
			}
		else
			{
			pReadTemp = devExt->pReadBuffer[bWhich] + devExt->PkHdr[nCapCount].offset;
			for (i = 0; i < devExt->PkHdr[nCapCount].length; i++)
				{
				if (bPPP)
					{
					if (pReadTemp[i] == 0x7E && eAtRes == STOP_LF)
						{
						bPPP = false;
						bPacket = true;
						}
					}
				else
					{
					switch (pReadTemp[i])
						{
						case 0x7E:
							if (eAtRes == STOP_LF)
								{
								bPPP = true;
							//	dwReadSize = 0;
								}
							break;

						case 'A':
							if (bAt == false && eAtRes != START_LF)
								{
								bAt = true;
							//	dwReadSize = 0;
								}
							break;

						case 0x0D:
							if (bAt == true)
								{
								bAt = false;
								eAtRes = START_CR;
								bPacket = true;
								}
							else
								{
								switch (eAtRes)
									{
									case START_LF:
										eAtRes = STOP_CR;
										break;

									case STOP_LF:
										eAtRes = START_CR;
									//	dwReadSize = 0;
										break;
										
									case SEPARATOR:
										eAtRes = START_LF;
										break;
									}
								}
							break;

						case 0x0A:
							switch (eAtRes)
								{
								case STOP_CR:
									eAtRes = STOP_LF;
									bPacket = true;
									break;

								case START_CR:
									eAtRes = START_LF;
									break;

								default:
									eAtRes = SEPARATOR;
									break;
								}
							break;

						default:
							if (bAt == false && eAtRes != START_LF)
								{
							//	eAtRes = START_LF;
							//	dwReadSize = 0;
								DBGOUT(("ppp packet loss!!!"));
								pTemp[dwReadSize] = 0x7E;	/// PPP loss...
								dwReadSize++;
								bPPP = true;
								}
							break;
						}
					}

				if (dwReadSize > 4094)
					{
					DBGOUT(("dwReadSize : %u", dwReadSize));
					bPacket = true;
					bPPP = true;
					}

				pTemp[dwReadSize] = pReadTemp[i];
				dwReadSize++;
				if (bPacket)
					{
				//	KeRaiseIrql(DISPATCH_LEVEL, &irql);
					ExAcquireFastMutex(&devExt->FMutex);
					devExt->pCaptureHdr[devExt->nMergeCount].code = devExt->PkHdr[nCapCount].code;
					devExt->pCaptureHdr[devExt->nMergeCount].offset = devExt->dwTotalOffset;
					devExt->pCaptureHdr[devExt->nMergeCount].length = (WORD)dwReadSize;
					devExt->pCaptureHdr[devExt->nMergeCount].tv = devExt->PkHdr[nCapCount].tv;
					RtlCopyMemory(devExt->pCaptureBuffer + devExt->dwMergeOffset, pTemp, dwReadSize);
					InterlockedExchangeAdd(&devExt->dwTotalOffset, dwReadSize);
					InterlockedExchangeAdd(&devExt->dwMergeOffset, dwReadSize);
					if (devExt->nMergeCount >= MAX_PACKET-1)
						{
						devExt->nMergeCount = 0;
						devExt->dwMergeOffset = 0;
						}
					else
						devExt->nMergeCount++;

					ExReleaseFastMutex(&devExt->FMutex);
				//	KeLowerIrql(irql);
					KeSetEvent(devExt->packet_Event, 0, FALSE);
					bPacket = false;
					dwReadSize = 0;
				//	DBGOUT(("read packet merge..."));
					}
				}
			}

		if (nCapCount >= MAX_PACKET-1)
			nCapCount = 0;
		else
			nCapCount++;

	//	irql = KeGetCurrentIrql();
	//	DBGOUT(("Capture thread len : %u", irql));
		}
	}

void KillThread(IN struct DEVICE_EXTENSION *devExt)
	{
	DBGOUT(("KillThread..."));
	devExt->bThreadStop = true;
	KeReleaseSemaphore(&devExt->pSemaphore, 0, 1, TRUE);
	KeWaitForSingleObject(&devExt->pThread, Executive, KernelMode, FALSE, NULL);
	ObDereferenceObject(&devExt->pThread);
	devExt->pThread = NULL;
	}

NTSTATUS CaptureInit(struct DEVICE_EXTENSION *devExt, bool bInit)
	{
	NTSTATUS status = STATUS_SUCCESS;
	if (bInit)
		{
		HANDLE hThread;
		TIME_DESYNCHRONIZE(&devExt->start_time);
		TIME_SYNCHRONIZE(&devExt->start_time);
		devExt->bThreadStop = false;
		status = PsCreateSystemThread(&hThread, 0, NULL, NULL, NULL, (PKSTART_ROUTINE)CaptureThread, devExt);
		if (NT_SUCCESS(status))
			{
			ObReferenceObjectByHandle(hThread, THREAD_ALL_ACCESS, NULL, KernelMode, (PVOID *)&devExt->pThread, NULL);
			ZwClose(hThread);
		
			devExt->pWriteBuffer[0] = ExAllocatePool(NonPagedPool, MAX_BUFFER);
			devExt->pWriteBuffer[1] = ExAllocatePool(NonPagedPool, MAX_BUFFER);
			devExt->pReadBuffer[0] = ExAllocatePool(NonPagedPool, MAX_BUFFER);
			devExt->pReadBuffer[1] = ExAllocatePool(NonPagedPool, MAX_BUFFER);
			devExt->pCaptureBuffer = ExAllocatePool(NonPagedPool, MAX_CAPTURE_BUFFER);
			devExt->pCaptureHdr = ExAllocatePool(NonPagedPool, nPKHDR_SIZE*MAX_PACKET);

			devExt->wWriteOffset[0] = 0;
			devExt->wWriteOffset[1] = 0;
			devExt->wReadOffset[0] = 0;
			devExt->wReadOffset[1] = 0;

			devExt->bWhichBuffer_read = 0;
			devExt->bWhichBuffer_write = 0;

			devExt->nCount = devExt->nMergeCount = 0;
			devExt->dwTotalOffset = devExt->dwMergeOffset = 0;
			devExt->readflag = CAPTURE_START;
			devExt->writeflag = CAPTURE_START;
			DBGOUT(("CaptureInit..."));
			devExt->bInit = true;
			}
		}
	else
		{
		DBGOUT(("Capture Release..."));
		devExt->readflag = CAPTURE_STOP;
		devExt->writeflag = CAPTURE_STOP;
		if (devExt->bThreadStop == false)
			KillThread(devExt);

		if (devExt->packet_Event)
			{
			ObDereferenceObject(devExt->packet_Event);
			devExt->packet_Event = NULL;
			}

		if (devExt->removeEvent_app)
			{
			ObDereferenceObject(devExt->removeEvent_app);
			devExt->removeEvent_app = NULL;
			}

		if (devExt->pWriteBuffer[0])
			ExFreePool(devExt->pWriteBuffer[0]);

		if (devExt->pWriteBuffer[1])
			ExFreePool(devExt->pWriteBuffer[1]);

		if (devExt->pReadBuffer[0])
			ExFreePool(devExt->pReadBuffer[0]);

		if (devExt->pReadBuffer[1])
			ExFreePool(devExt->pReadBuffer[1]);

		if (devExt->pCaptureBuffer)
			ExFreePool(devExt->pCaptureBuffer);

		if (devExt->pCaptureHdr)
			ExFreePool(devExt->pCaptureHdr);
		
		devExt->pWriteBuffer[0] = devExt->pWriteBuffer[1] = devExt->pReadBuffer[0] = devExt->pReadBuffer[1] = NULL;
		devExt->pCaptureBuffer = NULL;
		devExt->pCaptureHdr = NULL;

		devExt->wWriteOffset[0] = 0;
		devExt->wWriteOffset[1] = 0;
		devExt->wReadOffset[0] = 0;
		devExt->wReadOffset[1] = 0;
		devExt->bInit = false;
		TIME_DESYNCHRONIZE(&devExt->start_time);
		}

	return status;
	}

VOID TimerDpc(IN PKDPC pDpc, IN PVOID pContext, IN PVOID SysArg1, IN PVOID SysArg2)
	{
	struct DEVICE_EXTENSION* pDevExt = (struct DEVICE_EXTENSION*)pContext;
//	if (pDevExt)
	KeSetEvent(&pDevExt->kTimerEvent, 0, FALSE);
	}